## CQRS with Event Sourcing

Let's revise what was said about CQRS (designed using DDD) and Event Sourcing and describe how the two patterns connect together.

CQRS in its core is as simple concept as separation of read and write models for purpose of scalability and performance in multi-user collaborative environment. Domain-driven design fits nicely to this paradigm with the domain model being the core of the CQRS write model. Commands and events then manage state transition of the aggregates and creation of read models respectively; also, they can be used to communicate between aggregates and integrate other systems through messaging protocols.

In a simple CQRS implementation without event sourcing the state of the whole tree of aggregate's objects (entities, value objects) are persisted to storage. If the state of the aggregate is to change, it is loaded again, usually by a command handler, and an appropriate method is called that changes the internal state of the aggregate. After that, the aggregate is persisted again. Object-relational mapper (ORM) can be used to save the objects to desired storage. The process is shown in Figure \ref{fig:cqrs-no-es}.

In the case of event sourcing, the process flow is a bit different. The events are used to recreate the state of aggregates instead of loading the aggregate by ORM. These events are generated by the methods that handle the state change of the aggregate triggered by the command handlers. Instead of changing fields of aggregate entities or creating new value objects directly, a new event representing the state transition is created and applied to the aggregate. Applying the event results in calling the appropriate event handler in the aggregate that actually changes the state.

Now when the aggregate is loaded, instead of using ORM layer, all the events published by the aggregate in the past are read and applied to a completely new aggregate instance. By applying all the events one by one, their event handlers are called appropriately and the aggregate gets to the desired state to possibly process a method triggered by a command. After the command was handled, we do not save the state of the aggregate, but instead, all the new events marking new state changes that were applied to that aggregate are persisted to the event store. The event-sourced model is shown in Figure \ref{fig:cqrs-es}.

From the perspective of command handling you can see that event sourcing didn't bring any benefit; instead of mapping the whole object from ORM repository, it just continually builds the aggregate from a stream of events. And instead of saving the whole state of the aggregate, the new events that the aggregate published are saved. The benefit lies in that the structure of the aggregate is not bound to the ORM layer and can be changed anytime, for example, to fulfill new requirements. Also, testing of the domain model gets easier as the events can be used to set up the test, so they represent various use cases and situations in the domain. After processing a command under test, the published events are asserted. Another thing is that the events are stored and can be used for offline or batch processing, e.g. reports or monitoring which do not need to be updated in real-time.