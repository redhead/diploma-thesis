## CQRS with Event Sourcing

In this section, let's revise what was said about CQRS (designed using DDD) and Event Sourcing and describe how the two concepts connect together.

CQRS in its core is as simple concept as separation of read and write models for purpose of scalability and performance in multi-user collaboration environment. Domain-driven design fits nicely to this paradigm with the domain model being the core of the CQRS write model. Commands and events then manage state transition and creation of read models respectively as well as communication between aggregates and integration of other systems through messaging protocols.

In a simple CQRS implementation without event sourcing the state of the whole tree of aggregate's objects (entities, value objects) are persisted to storage. If the state of the aggregate is to change, it is loaded again, usually using command handler, and an appropriate method is called that changes the internal state of the aggregate. After that, the aggregate is persisted again. Object-relational mapper (ORM) can be used to save the objects to the desired database.

In case of event sourcing, the work flow is a bit different. The events are used to recreate the state of aggregates instead of loading the aggregate using ORM. These events are generated by the methods that handle the state change of the aggregate triggered by the command handlers. Instead of changing fields of aggregate entities or creating new value objects directly, a new event representing the state transition is created and applied to the aggregate. Applying the event results in calling the appropriate event handler in the aggregate that actually changes the state. 

Now when the aggregate is loaded, instead of using ORM layer, all the events published by the aggregate in the past are read and applied to a completely new aggregate instance. By applying all the events one by one, their event handlers are called appropriately and the aggregate gets to the desired state to possibly process a method triggered by a command. When the aggregate is saved after the command was handled, all the new events marking new state changes that were applied are persisted to the event store at the end of the event log.