
The advantage of this design is that we can compute many variations of projections to suit our needs --- we can populate the application state in a relational database, or create a search index for our data, etc. Since we store all events that happened in the system in our audit log, we can add a new projection at any time by simply processing all the historic events through a system that generates the new projection. Conceptual process flow of that processing is shown in Figure \ref{projections}.

Another example of a real-world event-sourced model can be found in many relational database engines. An interesting aspect of these database systems is that, internally, they usually keep some kind of a transaction log where they store all the changes that were applied to the database \cite{cqrsnu-eventsourcing}. This log is then used, for example, to handle database transactions, crash recovery, and replication. It is very easy to replicate data if they are represented as immutable events in an append-only, sequential log. To replicate, a node just needs to send the events that are new since the last replication and the receiving node applies these changes to itself, making both nodes synchronized \cite{replica}.

In summary, instead of storing the current state of the application, event sourcing primarily stores facts about changes (events) that happened to the application. The current state is degraded to be transient, meaning that we can throw it away and build it again just by processing events one by one. The benefits of this design are that we automatically get a correct audit log (in some cases required by the law), and a way to build the current state by making projections of the events. But there are other beneficial use cases, that would not be so straightforward or possible at all without it. The next paragraphs describe some of these cases for the reader to consider.