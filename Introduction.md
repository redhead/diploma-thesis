# Introduction

In software engineering and development, there are many problems the developers need to focus on to build a successful system. Many difficulties come early in the design phase of the software and developers had better have the knowledge and the proper tools to design and build the software, so it is successful, bug-free, maintainable, and usable. The trouble is that there is no single "right way", a silver bullet, which can be used universally in software development because of the complex nature of a domain that the projects usually solve. And of course, even experienced software developers cannot possibly know every problem the software can run into later in development.

However, a successful project --- that is a project built according to customers' needs, in time, and on budget --- does not say anything about the project internal code and design quality. The project, even if it works as required, may be very brittle to change in its internals and the code may be so complex that maintenance becomes very hard. This can result in the introduction of bugs into the code that are, consequently, difficult to find and fix. This situation usually happens in projects that need to respond to changing requirements.

Some of the problems turned out to be so common that they needed to be addressed in most of the projects, and so, over time, so-called patterns and best practices formed to help solve the problems, or, at least, diminish their effect. So, one of the best things software developers can have is the knowledge of these patterns and best practices that were already used and proven to work by someone else. This knowledge allows them to tackle some of these common problems while making the code and design easy to understand, maintain, change, and extend. This applies not only after the project is done but also during the development of the software itself, where numerous problems can emerge. Choices taken prior to starting the development of some software, even if they were thought through carefully, may not take into account problems that might come during the development.

In recent years, there has been a notable shift in how applications are run and built. More and more, applications are being moved from the on-premise environments to the web. This has a number of advantages, e.g. the application can run on multiple devices, it supports instant updates, the project can target a bigger audience, etc. Cloud computing certainly had its part in the process. Inevitably, the situation brought new problems into the web software development that the known patterns did not address in that environment, e.g. fine-grained scalability, performance, changing requirements, multitenancy, multiuser collaboration, etc. All this also affects how the applications are structured and designed. If projects are expected to grow, the applications that target the web must be prepared for the problems it entails. 

New patterns and practices evolved in the meantime to address the new issues. Event sourcing and its companion Command Query Responsibility Segregation (CQRS) are two examples which have been highly discussed in articles and conferences in the last years. Their core ideas and benefits are interesting enough to aim the attention at their details and implementation. And since Java is one of the most used programming languages in the enterprise software development \cite{java}, it is appropriate to study and apply the patterns using this language.

## Goals

The goal of this diploma thesis and the work behind it was to study the basic principles of the Event Sourcing and Command Query Responsibility Segregation patterns and to implement them into a real-world software project written in the Java programming language. Additionally, it aimed at comparing the design patterns with the traditional architecture of enterprise applications.

## About the text

The following chapters explain the basic ideas, benefits, and disadvantages of the patterns, and describe the path taken in implementing the patterns into an existing software project written in Java --- Integration Portal --- in which the benefits over the original design are practically examined. 

The first part of the thesis describes the idea of Event Sourcing and the Command Query Responsibility Segregation design pattern, which is usually implemented in tandem with Event Sourcing. The second part introduces the Integration Portal project and its original design that was, as part of this diploma thesis, subjected to refactoring into Event Sourcing and CQRS design. Finally, the whole process and the experience are described together with a discussion of the issues that were introduced by the refactoring and suggestions of how they could be handled.

In conclusion, this thesis should provide enough necessary information to obtain a basic understanding of Event Sourcing and CQRS and describe the advantages and disadvantages of this design, both in general and in Java implementation.