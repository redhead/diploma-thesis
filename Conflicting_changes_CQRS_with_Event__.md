### Conflicting changes

CQRS with Event Sourcing, on top of the benefits presented above, provides a great way of dealing with conflicting changes in one aggregate. This usually happens when two users want to modify data on the same aggregate nearly at the same time. One way to solve this problem is by versioning the aggregates. Every time the aggregate is saved, i.e. new events are stored and published in reaction to a command, the version of the aggregate is incremented. When both users are working with the aggregate of the same version and both send a command to alter the state of the aggregate, we can send the aggregate's version together with the command. In the command handler, we can assert that the aggregate we want to load to process the command is of that version and if not reject the command because of conflicting modification.

A better way than just rejecting the command altogether is to resolve if the changes caused by a command are in fact conflicting. An example of a conflicting change can be that both users update the same field but to a different value, e.g. year of the product release. On the other hand, if the changes are non-conflicting, e.g. one user updates year of the product release and the other fixes a typo in the product title, then we can handle both commands successfully despite operating on the same aggregate version. This conflicting modification can be determined by comparing two lists of events. One list contains events saved by the aggregate since the last known version (the unexpected events for the command) and the second list contains new events applied by the command the user sent. If there is a pair of events from both lists that are in conflict (e.g. two "*product release year changed*" events), an exception can be raised notifying about the conflicting changes.