However, this is not the only conceptual model that can represent an order. Other solutions offer different properties that suit other use cases better. For example, a relational database is not very suitable for full-text indexing and searching. Other systems would benefit more if they used a graph database for some part of the application instead. The point is that there is no single model that could be used universally for every possible case that the system needs to address. Moreover, the structure of the application data tends to change over time. 

In an event-sourced model, the structure of the current state is irrelevant. To make the explanation clear, let's take an example from bookkeeping or bank accounts where everything is stored as a list of accounting entries, or entries of money deposits and withdrawals. When you receive your bank statement, you can see that it's presented as a list of entries specifying what happened to your account each time a transaction happened and how much money was involved in each transaction. If you take all these entries and sum them up (positive values for deposits, and negative for withdrawals) you get your total account balance. This is how banks worked and are still working --- they keep all these entries as a history of account transactions and by summing them, they calculate the account balance.

However, by keeping only the current state (balance of a bank account), a lot of valuable historic data is lost, e.g. the information about the time a state change happened, who invoked the change, and so on. This historic data may remind you of something called an audit log. 

An audit log is the very same thing as the bank statement from the accounting example. It is effectively a log of events that happened to the account throughout its entire existence. System administrators may use the audit log to learn who did what in the system and track the corresponding changes. Many systems actually need an audit log (banking systems by their nature do) for the purpose of regulation or auditing. 

In many systems, an audit log is a separate module that is updated by the code handling the state changes. However, this way may be error-prone as developers who make changes to the code must be very disciplined and remember to update the audit log to store the correct event in the log. As the system grows bigger, it may take a lot of effort to maintain the audit log, and, more importantly, prove it is correct!

Event Sourcing takes the opposite approach. It makes the audit log the core concept for system state transitioning. That means the source for a system's state is the audit log, a list of events, in the first place. From this log the current state of the application can be computed, much like the account balance is computed from the list of account entries. For example, see the Figure \ref{events}. This computed value would be called a projection. It may be viewed as a function of a list of events which returns a projection of those events. 


