However, this is not the only conceptual model to represent an order. Other solutions offer different properties that suit other use cases better. For example, a relational database is not very suitable for full text indexing and searching. Other systems would benefit more if they used a graph database for some part of the application instead. The point is that there is no single model that could be used universally for every possible case that the system needs to address. Moreover, the structure of the application data tend to change over time. 

In an event-sourced model, the structure of the current state is irrelevant. To make the explanation clear, let's take an example from bookkeeping or bank accounts where everything is stored as a list of accounting entries, or entries of money deposits and withdrawals. When you receive your bank statement, you can see that it's presented as a list of entries specifying what happened to your account each time a transaction happened and how much money was involved in each transaction. If you take all these entries and sum them up (positive values for deposits, and negative for withdrawals) you get your total account balance. This is how banks worked and are still working --- they keep all these entries as a history of account transactions and by summing them, they calculate the account balance.

However, by keeping only the current state (balance of a bank account), a lot of valuable historic data is lost, e.g. the information about the time a state change happened, who invoked the change, and so on. This historic data may remind you of something called an audit log. 

An audit log is the very same thing as the bank statement from the accounting example. It is effectively a log of events that happened to the account throughout its entire existence. System administrators may use the audit log to learn who did what in the system and track the corresponding changes. Many systems actually need an audit log (banking systems by their nature do) for the purpose of regulation or auditing. 

In many systems, an audit log is a separate module that is updated by the code handling the state changes. However, this way may be error-prone as developers who make changes to the code must be very disciplined and remember to update the audit log to store the correct event in the log. As the system grows bigger, it may take a lot of effort to maintain the audit log, and, more importantly, prove it is correct!

Event Sourcing takes the opposite approach. It makes the audit log the core concept for system state transitioning. That means the source for a system's state is the audit log, a list of events, in the first place. From this log the current state of the application can be computed, much like the account balance is computed from the list of account entries. 

This computed value would be called a projection. It may be viewed as a function of a list of events which returns a projection based on that list of events. Usually, the events are applied to an intermediate state one by one. For example, see Figure X**reference needed**.

The advantage of this design is that we can compute many variations of projections to suit our needs --- we can populate the application state in a relational database, or create a search index for our data, etc. Since we store all events that happened in the system in our audit log, we can add a new projection at any time by simply processing all the historic events through a system that generates the new projection.

Another example of a real-world event-sourced model can be found in many relational database engines. An interesting aspect of these database systems is that, internally, they usually keep some kind of a transaction log where they store all the changes that were applied to the database**citation needed**[http://cqrs.nu/Faq/event-sourcing]. This log is then used, for example, to handle database transactions, crash recovery, and replication. It is very easy to replicate data if they are represented as immutable events in an append-only, sequential log. To replicate, a node just needs to send the events that are new since the last replication and the receiving node applies these changes to itself, making both nodes synchronized**citation needed**[https://www.percona.com/blog/2013/01/09/how-does-mysql-replication-really-work/].

In summary, instead of storing the current state of the application, event sourcing primarily stores facts about changes (events) that happened to the application. The current state is degraded to be transient, meaning that we can throw it away and build it again just by processing all the events one by one. The benefits of this design are that we automatically get a correct audit log (in some cases required by the law), and a way to build the current state by making projection(s) of the events.

The use of Event Sourcing can provide many beneficial use cases, that would not be so straightforward or possible at all without it. The next paragraphs describe some of these cases for the reader to consider.

