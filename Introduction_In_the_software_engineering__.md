# Introduction

In the software engineering and development, there are many problems that are usually already solved or there exists a way of diminishing these problems using known patterns and best practices. Many such difficulties come already in the design phase of the software and developers better have the knowledge and right tools to design the software right. The trouble is that there is no "right" in software development. Many of the problems are so new, that nobody ever made an attempt of solving them. And of course, even experienced software developers cannot possibly know every problem the software can run into later in development. We can measure "right" only by success of the project, i.e. building the software according to customers needs, in time, and on budget.

This however does not say anything about the project internal code and design quality. A successful project may be in its internals very brittle to change and the code may be so complex that maintenance becomes very hard. This can result in introduction of bugs into the code, which are consequently difficult to find and fix. 

So, one of the best things software engineers should have is knowledge of the patterns and best practices that were already used and proven working by someone else to tackle some of these common problems. Making the code and design easy to maintain, change, and extend. And that not only after the project is done but also during the development of the software itself, where numerous problems can emerge (e.g. customers requirements changed, or unexpected issue was found).

Thus, choices taken prior starting the software development, even though they were thought through carefully, may not cover the problems that come during the development. This is were design patterns and best practices are the way of helping the software development out of the problems or easing them.

It is not uncommon in software development world that principles make their way into every day usage long time after they were published or examined by their creators. Take an example of functional programming, principles of which were described in 1930s, implemented into Lisp programming language in 1950s but never being part of mainstream software development until the start of 21<sup>st</sup> century where a boom of new functional programming languages happened.

The Event Sourcing design pattern took a similar path. The core idea of Event Sourcing is being used for ages but not so much in typical software development. You can get the idea of this pattern from bookkeeping or bank accounts where everything is stored as a list of accounting entries, or entries of money deposit and withdrawal. When you get your bank statement, you can see it is presented as a list of entries specifying what happened to your account each time a transaction happened and how much money was involved in each transaction. If you take all these entries and sum them (positive values for money deposit, and negative for withdrawal) you get your total account balance. This is how banks worked and are still working - they keep all these entries as a history of account transactions and by summing them we get the account balance.

Now, let's get back to software development. A traditional software design that you can find in many books and online tutorials usually stores things by keeping only the current state of the application in a relational or document database. This may seem as something that is really needed from the system because the users of the application usually want to see the current data and interact with it. However, by keeping only the current state (balance of a bank account) we lose a lot of valuable historic data. We lose the information about the time a state change happened, who invoked the change, and so on. This historic data may remind you of something called an audit log. 

An audit log is the very same thing as the bank statement from the accounting example. It is effectively a log of events that happened to the account in its entire existence. Many systems actually need an audit log (banking systems by their nature do) for the purpose of regulation or auditing. But in many systems, an audit log is a separate module called by the code that is handling a state change. However, this way may be error-prone as developers who make changes to the code must be very disciplined and know to call the audit log to store the correct change into the log. As the system grows bigger, it may take a lot of effort to maintain such audit log and more importantly prove its correctness!

Event Sourcing takes an approach that makes the audit log the core concept of the system. That means the system is actually an audit log itself instead of representation of the current state. And from this log the current state of the application is computed dynamically, much like the account balance is computed from the list of account entries.