
If each of the two concerns is separated to a different module, it provides us some benefits described in the following paragraphs.
 
### Rationale

There are few reasons to consider splitting the two responsibilities. First is that reading the application data (querying) is not something that usually needs transactional invariants to be involved; that is something commands need to address. A query just returns data. On top of that, queried data are usually represented in the form of screens (or, based on your use cases, other types of an interface) that the users are presented with, so the perception of queried data on a screen can be different than the model used to alter the data. This model, sometimes called a write model, must uphold transactional invariants or business rules of domain entities and it is usually subject to concurrent changes and/or multi-user collaboration.

The second, more important thing is that usually it is the read side of your application that needs to be scaled to ensure the quality of your system for a bigger audience. In many systems, a ratio of reads to writes can be several orders of magnitude \cite{cap}. Instead of scaling everything in the system it is better to focus on the part of the application that is most heavily used, i.e. the read side.

This leads us to an interesting aspect of most queries and that is relaxed consistency. In round-trip based web applications, users already interact with stale data in their browsers. Imagine the time that a response takes to return from a server to a user and the time the user spends viewing the screen before making interaction. At any point, the data could have been mutated on the server by other users or the system itself and so, the user sees data that is inconsistent with the server. So, relaxing the consistency of queried data, so it can be easily scaled, is not a big issue. The important thing to mention here is that relaxing the consistency does not mean that the data is inconsistent on the read side. It is rather **eventually consistent**; that means that correct and consistent data is returned by the query at some point, but it just may not be immediate. The delay before the read side is updated is not something that would break the system in most cases.

This, however, does not apply to the write side where it is necessary to always operate on the current state to reliably ensure full consistency. This means that the write side is usually a lot harder to scale and to ensure being consistent at the same time. But, depending on the type of your system, scaling the write side is not always needed.

As a final note on reasons for using CQRS, let's mention that it enables the application to easily have different types of read models running in parallel. In many cases, the application needs to query its data from different types of data models to function well. As an example, a full-text search is not something very efficient to do in a relational database. The same applies when querying data that are structured as graphs. A single model that does everything right does not exist; some models do things better than others in specific circumstances. CQRS together with Event Sourcing enables us to create multiple read models of different types very easily.

### Terminology

Before we get into implementing CQRS and Event Sourcing in Java it is necessary to explain some of the terminology used in the process. In \cite{journey}, the CQRS pattern was presented as hugely influenced by the approach to developing software systems known as the Domain-Driven Design methodology (DDD). The DDD approach describes a set of techniques to analyze the domain of the system and to construct a conceptual model from the results of that analysis. This model is then used for designing large and complex domains and helps you solve the problems in the domains.

However, it is essential to say that DDD does not dictate the usage of CQRS, nor CQRS needs DDD for it to be implemented in the system. However, in much of the existing literature these two principles are used together and many CQRS practitioners use the terminology of DDD \cite{journey}.

Because of that, let us succinctly describe some of the DDD concepts and terminology that are usually involved in the CQRS pattern in the following paragraphs. Relations of the terms in a complex system  is shown in Figure \ref{fig:ddd}. You can find more information about DDD in \cite{ddd}.
